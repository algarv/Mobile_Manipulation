from modern_robotics import *
import numpy as np 
from numpy import sin, cos, pi
import matplotlib.pyplot as plt 
from NextState import NextState
from TrajectoryGenerator import TrajectoryGenerator, flatten
from FeedbackControl import FeedbackControl

'''
FUNCTION CALL:
mobile_manipulation(Kp_val, Ki_val, speed_limit, x_init, y_init, x_final, y_final)

Note: Update CSV file lines of the function with a valid file path for the output csv file
'''

def mobile_manipulation(Kp_val, Ki_val, speed_limit, x_init, y_init, x_final, y_final):
    '''
    Inputs: 
        Kp_val: proportional controller gain value (will be multiplied by an identity matrix)
        Ki_val: integral controller gain value (will be multiplied by an indentity matrix)
        speed_limt: maximum rotational velocities of the wheel and arm joints
        x_init: x coordinate of the initial position of the cube
        y_init: y coordinate of the initial position of the cube
        x_final: x coordinate of the initial position of the cube
        y_final: y coordinate of the initial position of the cube
    Outputs: 
        None
        Writes 2 CSV files to store the robot trajectory and the error at each step
    '''
    l = 0.47/2
    w = 0.3/2
    r = 0.0475

    #Initial position of the end effector in the world frame (estimated, will change depending on the robot's initial configuration)
    Tse_init = np.array([[0, 0, 1, 0],
                        [0, 1, 0, 0],
                        [-1,0, 0, 0.5],
                        [0, 0, 0, 1]])

    #Initial and final block positions in the world frame (given)
    Tsc_init = np.array([[1, 0, 0, x_init],
                        [0, 1, 0, y_init],
                        [0, 0, 1, .025],
                        [0, 0, 0, 1]])


    Tsc_final = np.array([[0, 1, 0, x_final],
                        [-1, 0, 0, y_final],
                        [0, 0, 1, .025],
                        [0, 0, 0, 1]])

    #Position of the end effector relative to the cube for grasping. The cube will be grasped at a 45 degree angle.
    Tce_grasp = np.array([[cos(-5*pi/4), 0, sin(-5*pi/4), 0],
                        [0,         1,      0, 0],
                        [-sin(-5*pi/4),  0, cos(-5*pi/4),0],
                        [0, 0, 0, 1]])

    Tce_standoff = np.array([[cos(-5*pi/4), 0, sin(-5*pi/4), 0],
                            [0,         1,      0, 0],
                            [-sin(-5*pi/4),  0, cos(-5*pi/4),.1],
                            [0, 0, 0, 1]])

    Tb0 = np.array([[1,0,0,0.1662],
                    [0,1,0,0],
                    [0,0,1,0.0026],
                    [0,0,0,1]])

    F = (r/4) * np.array([[-1/(l+w),1/(l+w),1/(l+w),-1/(l+w)],[1,1,1,1],[-1,1,-1,1]])

    F6 = np.array([[0,0,0,0],[0,0,0,0],F[0],F[1],F[2],[0,0,0,0]])

    k = 1

    Kp = Kp_val * np.array([[1,0,0,0,0,0],[0,1,0,0,0,0],[0,0,1,0,0,0],[0,0,0,1,0,0],[0,0,0,0,1,0],[0,0,0,0,0,1]])
    Ki = Ki_val * np.array([[1,0,0,0,0,0],[0,1,0,0,0,0],[0,0,1,0,0,0],[0,0,0,1,0,0],[0,0,0,0,1,0],[0,0,0,0,0,1]])

    B_list = np.array([[0,0,1,0,.033,0],[0,-1,0,-0.5076,0,0],[0,-1,0,-0.3526,0,0],[0,-1,0,-.2176,0,0],[0,0,1,0,0,0]])
    B_list = B_list.T
    Mo = np.array([[1,0,0,.033],[0,1,0,0],[0,0,1,.6546],[0,0,0,1]])

    #Caclulate end effector trajectory using the TrajectoryGenerator function
    print('Calculating end effector trajectory')
    ee_configurations = TrajectoryGenerator(Tse_init, Tsc_init, Tsc_final, Tce_grasp, Tce_standoff, k)
    x_err_acc = ([0,0,0,0,0,0])
    dt = .01

    #Initial configuration of the robot
    Tsr = [.75,0,.2,0,0,0,0,0,0,0,0,0]
    V_joints = [0,0,0,0,0,0,0,0,0]

    print('Calculating robot trajectory')
    traj_list = [Tsr+[0]]
    acc_err_list = []
    err_list = []
    err_Rx = []
    err_Ry = []
    err_Rz = []
    err_x = []
    err_y = []
    err_z = []
    for i in range(0,len(ee_configurations)-1):
        '''
        Loop through each end effector configuration generated by the TrajectoryGenerator function and construct the robot configuration
        for each step
        '''
        
        #Store the current robot configuration value before re-writing the variable
        Tsr_old = Tsr.copy()
        
        #Take the current and following end effector configurations for reference trajectories 
        traj_ref = ee_configurations[i]
        Tse_ref = np.array([[traj_ref[0],traj_ref[1],traj_ref[2],traj_ref[9]],[traj_ref[3],traj_ref[4],traj_ref[5],traj_ref[10]],[traj_ref[6],traj_ref[7],traj_ref[8],traj_ref[11]],[0,0,0,1]])

        traj_ref_next = ee_configurations[i+1]
        Tse_ref_next = np.array([[traj_ref_next[0],traj_ref_next[1],traj_ref_next[2],traj_ref_next[9]],[traj_ref_next[3],traj_ref_next[4],traj_ref_next[5],traj_ref_next[10]],[traj_ref_next[6],traj_ref_next[7],traj_ref_next[8],traj_ref_next[11]],[0,0,0,1]])

        #Find the actual configuration of the end effector using the previous iteration's configuration
        theta_joints = Tsr[3:8]
        T0e = FKinBody(Mo, B_list, theta_joints)

        phi = Tsr[0]
        x = Tsr[1]
        y = Tsr[2]
        Tsb = np.array([[cos(phi),-sin(phi), 0,  x], 
                    [sin(phi), cos(phi),  0,  y], 
                    [0,        0,         1,  0.0963],
                    [0,        0,         0,  1]])
        Tbe = Tb0 @ T0e
        Tse = Tsb @ Tbe

        #Apply the FeedbackControl function using the reference configurations and the actual configuration
        Ve, x_err_acc, x_err = FeedbackControl(Tse, Tse_ref, Tse_ref_next, Kp, Ki, x_err_acc, dt)

        #Find the end effector jacobian using the body and arm jacobians and use it to find wheel and arm joint velocities
        Jb = Adjoint(TransInv(T0e)@TransInv(Tb0)) @ F6
        Jarm = JacobianBody(B_list, theta_joints)
        Je = np.hstack([Jb,Jarm])

        V = np.linalg.pinv(Je) @ Ve

        V_joints = np.array([V[4],V[5],V[6],V[7],V[8],V[0],V[1],V[2],V[3]])

        #The previous robot configuration and joint velocities are then used with NextState to find the next robot configuration
        Tsr = NextState(Tsr_old, V_joints, dt, speed_limit)

        #Store the configuration and error values
        traj = Tsr + [traj_ref[-1]]
        traj_list.append(traj)

        acc_err_list.append(x_err_acc)
        err_list.append(x_err)
        err_Rx.append(x_err[0])
        err_Ry.append(x_err[1])
        err_Rz.append(x_err[2])
        err_x.append(x_err[3])
        err_y.append(x_err[4])
        err_z.append(x_err[5])

    print('Writing CSV files')
    #np.savetxt("/home/algarverick/ME_449/FinalProject/results/newTask.txt",traj_list,delimiter=",")
    #np.savetxt("/home/algarverick/ME_449/FinalProject/results/best/newTask.txt",err_list,delimiter=",")

    print('Plotting error')
    x_axis = np.linspace(0,50,len(acc_err_list))

    plt.plot(x_axis,err_Rx, label="Rx")
    plt.plot(x_axis,err_Ry, label="Ry")
    plt.plot(x_axis,err_Rz, label="Rz")
    plt.plot(x_axis,err_x, label="x")
    plt.plot(x_axis,err_y, label="y")
    plt.plot(x_axis,err_z, label="z")
    plt.title('Accumulated Error')
    plt.xlabel('Time')
    plt.ylabel('Error')
    plt.legend()
    plt.show()